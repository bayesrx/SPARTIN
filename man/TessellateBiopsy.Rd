% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/TessellateBiopsy.R
\name{TessellateBiopsy}
\alias{TessellateBiopsy}
\title{Tessellates a window into sub-windows that the models are ultimately fit on.}
\usage{
TessellateBiopsy(
  full.tib,
  sigma,
  eps,
  threshold,
  clust.size,
  max.clust.size = NULL,
  min.clust.size = NULL,
  enforce.contiguity = TRUE,
  clust.method = "kmeans",
  progress = TRUE
)
}
\arguments{
\item{full.tib}{Full tibble representing all cells in the biopsy to be
tessellated. Should have three columns: CentroidX, CentroidY, and Mark.}

\item{sigma}{Radius of kernel smoothing used in intensity thresholding. Larger
radius means less white space.}

\item{eps}{Size of "pixel" that window is divided into for intensity
thresholding. Note that this parameter tends to be the "bottleneck"- it's
best to start larger, and see how small a value is necessary and/or
computationally feasible.}

\item{threshold}{Minimum value of pixels to keep in intensity threshold. Too
large of a value will result in the tessellation being "choppy," i.e. too
much of the space will be thresholded out, and too small of a value
will result in a tessellation with too much white space.}

\item{clust.size}{Target number of type 1 points in each cluster. In all
likelihood this won't be exactly satisfied.}

\item{max.clust.size}{Maximum number of type 1 points allowed in a cluster.
clusters with more than this number of points will be recursively split
into smaller clusters until they have fewer points than this bound.}

\item{min.clust.size}{Minimum number of type 1 points allowed in a cluster.
Clusters with fewer than this number of points will not be included in the
final partition.}

\item{enforce.contiguity}{Determines whether each resulting tile should be
contiguous. If true, keeps largest contiguous portion of each tile,
provided it has enough points to meet the threshold.}

\item{clust.method}{Determines how dirichlet tessellation
tiles are grouped into larger tiles. Must be either "greedy" or "kmeans."
While both work, "kmeans" is strongly recommended at the moment.}

\item{progress}{Boolean; if "TRUE," prints updates to the console.}
}
\value{
a list with four attributes. "tiles" is a list where each entry is
a spatstat ppp object corresponding to each tile the space has been
partitioned into. "pp" is a spastat ppp object corresponding to the overall
intensity thresholded space and points. "pixels" is a matrix of the "pixels"
that the window is divided into for intensity thresholding, as well as the
values assigned to each pixel by the kernel smoothing. "window" is the
overall window that results from the tessellation; this is equivalent to
$pp$window.
}
\description{
Tessellates a window into sub-windows that the models are ultimately fit on.
}
